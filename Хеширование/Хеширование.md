# Хеширование

Хеширование представляет собой эффективную и практичную технологию, благодаря которой мы можем быстро сохранять и получать доступ к информации по ключам.
Чтобы получить хеш-ключ для определенной информации (значения) вводится понятие хеш-функции, которая преобразует значение в хеш-ключ по определенному
алгоритму.

Основные операции при работе с хеш-таблицами: вставка элемента, удаление элемента, поиск элемента.

Основные недостатки: сложно придумать универсальную хеш-функцию, которая не порождала бы коллизии. Коллизия возникает тогда, когда хеш-функция для разных значений создает один и тот же хеш-ключ. В таком случае (к примеру) используется метод цепочек для разрешения коллизий.

## Пример коллизии

Пусть у нас есть следующая хеш-функция: f(x) = x % 5, где x - целое число и массив table размерности m = 5. В таком случае, для чисел 5, 10, 15, ..., хеш-функция всегда будет выдавать одинаковый хеш-ключ - это и есть пример коллизии. То есть в table[0] нам надо как-то поместить все числа, которые удовлетворяют следующему равенству: x % 5 == 0. Для этого мы можем использовать метод цепочек.

## Разрешение коллизий методом открытой адресации

При вставке нового элемента происходит попытка разместить его в таблице на соответствующей позиции, определённой хеш-функцией. Если позиция занята, то начинается поиск следующей свободной позиции в таблице.

## Разрешение коллизий методом двойного хэширования

Двойное хеширование — метод борьбы с коллизиями, возникающими при открытой адресации, основанный на использовании двух хеш-функций для построения различных последовательностей исследования хеш-таблицы. При двойном хешировании используются две независимые хеш-функции h1(x) и h2(x).

## Разрешение коллизий методом внешних цепочек

При использовании метода цепочек для борьбы с коллизиями используется структура данных LinkedList (двусвязный список). При таком методе каждый индекс массива (table)
содержит указатель на начало списка. При возникновении коллизии мы просто добавляем элмент в конец списка, а не ищем другое свободное место. В этом случае наихудшее время поиска элемента будет за O(table[i].Length), а вставка элемента за O(1).

## Разрешение коллизий методом линейного пробирования

У нас все так же есть массив table размерности m. Пусть задана обычная вспомогательная хеш-функция h' : U -> {0, 1, ..., m-1}. Метод линейного пробирования использует хеш-функцию: h(x, i) = (h'(x) + i) mod m для i = 0, 1, ..., m - 1.


## Разрешение коллизий методом квадратичного пробирования

Метод квадратичного пробирования работает аналогично методу линейного пробирования, только при этом использует следующею хеш-функцию: h(x, i) = (h'(x) + c1*i + c2*i^2) mod m, для i = 0, 1, ..., m - 1 и вспомогательных констант c1 и c2.